"""
File Name              :   jup_common_functions_tiles
Author                 :   Ashwin Kumar
Date Created           :   2016-12-20
Description            :  common functions that are used in tiles calculation

MODIFICATIONS LOG         :
    S.No                   :
    Date Modified          :
    By                     :
    Modification Details   :
"""
from jupiter_AI.network_level_params import Host_Airline_Hub as host_hub
from copy import deepcopy
import datetime
import random
import string
from datetime import date, time
# from datetime import datetime

"""
The following function calculates the month and year value between two dates. This is
required for collections where a date field is not present whereas a month and year field
are present
"""


def query_month_year_builder(stdm, stdy, endm, endy):
    m = deepcopy(endm)
    y = deepcopy(endy)
    month_year = []
    if endy == 9999:
        list_query = [
            {
                'month': {'$gte': stdm},
                'year': stdy
            }
            ,
            {
                'year': {'$gt': stdy}
            }
        ]
        return list_query
    else:
        while True:
            month_year.append({'month': m,
                               'year': y})
            if m == stdm and y == stdy:
                break

            m -= 1
            if m == 0:
                m = 12
                y -= 1
        return month_year

"""
The following function retreives username present in the credentials.txt file located in
jupiter_AI/common folder
"""


def get_user_name():
    import os.path
    dir_path = os.path.dirname(os.path.realpath(__file__))
    if os.path.isfile(os.path.join(dir_path, '../common/credentials.txt')):
        file_path = os.path.join(dir_path, '../common/credentials.txt')
        file_cred = open(file_path, 'r')
        cred = file_cred.read()
        file_cred.close()
    elif os.path.isfile(os.path.join(dir_path, '../common/credentials')):
        file_path = os.path.join(dir_path, '../common/credentials')
        file_cred = open(file_path, 'r')
        cred = file_cred.read()
        file_cred.close()
    else:
        cred = ''
    return cred


"""
The following function gen_collection_name() generates a random name. This random name will be used to name a collection
created by the aggregate function. The aggregate function of mongodb writes all of its outputs to
a collection which has a name generated by this function.

The name is a combination of random characters and the time when the function is being called. This is to
ensure there are no duplications while naming the collections
"""


def gen_collection_name():
    try:
        time_stamp = datetime.datetime.now().isoformat()
        random_string = ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(8))
        user_name = get_user_name()
        if user_name == '':
            user_name = "Vishnu"
            # raise Exception("Collection name not generated. Check if credentials.txt exists")
        collection_name = 'JUP_Temp_' + user_name + '_' + time_stamp +'_'+ random_string
        return collection_name
    except Exception as err_msg:
        return err_msg


"""
the following code get_od_list_leg_level will break the given origin destination combo
to leg level origin destination if the hub of the host airline is neither the origin
nor the destination

example: origin - BLR and destination - DOH

neither the origin nor the destination is the hub for the host airline in the above example.

therefore, the od - BLRDOH will be broken down to BLR(hub) and (hub)DOH
"""


def get_od_list_leg_level(dict_scr_filter):
    od_build = []
    for idx, item in enumerate(dict_scr_filter['origin']):
        if item != host_hub and dict_scr_filter['destination'][idx] != host_hub:
            od1 = ''.join(item + host_hub)
            od_build.append({'od': od1})
            od2 = ''.join(host_hub + dict_scr_filter['destination'][idx])
            od_build.append({'od': od2})
        else:
            od = ''.join(item + dict_scr_filter['destination'][idx])
            od_build.append({'od': od})
        od_build = [i for n, i in enumerate(od_build) if i not in od_build[n + 1:]]
    return od_build


"""
The following function determines whether a year is a leap year or not

"""
def leap(year):
    if (year % 4) == 0:
        if (year % 100) == 0:
            if (year % 400) == 0:
                return 1
            else:
                0
        else:
            return 1
    else:
        return 0


def prev_year_range(From, To):

    From_obj = datetime.datetime.strptime(From, '%Y-%m-%d')
    To_obj = datetime.datetime.strptime(To, '%Y-%m-%d')
    if int(From_obj.month) != 2 and int(To_obj.month) != 2:
        From_date = str(From_obj.year - 1) + '-' + str(From_obj.month) + '-' + str(From_obj.day)
        To_date = str(To_obj.year - 1) + '-' + str(To_obj.month) + '-' + str(To_obj.day)
    else:
        if leap(int(To_obj.year)) and int(To_obj.day) == 29:
            To_date = str(To_obj.year - 1) + '-' + str(To_obj.month) + '-' + str(int(To_obj.day) - 1)
            From_date = str(From_obj.year - 1) + '-' + str(From_obj.month) + '-' + str(From_obj.day)
        else:
            if leap(int(From_obj.year)) and int(From_obj.day) == 29:
                From_date = str(From_obj.year - 1) + '-' + str(From_obj.month) + '-' + str(int(From_obj.day) - 1)
                To_date = str(To_obj.year - 1) + '-' + str(To_obj.month) + '-' + str(To_obj.day)

    From_date = datetime.datetime.strptime(From_date, '%Y-%m-%d').strftime('%Y-%m-%d')
    To_date = datetime.datetime.strptime(To_date, '%Y-%m-%d').strftime('%Y-%m-%d')
    return From_date, To_date


if __name__ == '__main__':
    name = gen_collection_name()
    print name